<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lab1/ressources/mongodb_keywords.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/ressources/mongodb_keywords.py" />
              <option name="updatedContent" value="from robot.api import logger&#10;from robot.api.deco import keyword, library&#10;from pymongo import MongoClient&#10;import re&#10;&#10;@library&#10;class MongoDBLibrary:&#10;    &quot;&quot;&quot;Library for MongoDB operations in Robot Framework.&quot;&quot;&quot;&#10;&#10;    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'&#10;    ROBOT_LIBRARY_VERSION = '1.0'&#10;&#10;    def __init__(self):&#10;        self._client = None&#10;        self._db = None&#10;&#10;    @keyword('Connect To Database')&#10;    def connect_to_database(self, uri, db_name=&quot;fakestore&quot;):&#10;        &quot;&quot;&quot;Connect to MongoDB database.&quot;&quot;&quot;&#10;        try:&#10;            self._client = MongoClient(uri)&#10;            # Test connection&#10;            self._client.admin.command('ping')&#10;            self._db = self._client[db_name]&#10;            logger.info(f&quot;Connected to MongoDB database: {db_name}&quot;)&#10;            return True&#10;        except Exception as e:&#10;            logger.error(f&quot;Failed to connect to MongoDB: {str(e)}&quot;)&#10;            raise RuntimeError(f&quot;Connection failed: {str(e)}&quot;)&#10;&#10;    @keyword('Disconnect From Database')&#10;    def disconnect_from_database(self):&#10;        &quot;&quot;&quot;Disconnect from MongoDB database.&quot;&quot;&quot;&#10;        try:&#10;            if self._client:&#10;                self._client.close()&#10;                self._client = None&#10;                self._db = None&#10;                logger.info(&quot;Disconnected from MongoDB&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error during disconnect: {str(e)}&quot;)&#10;            raise RuntimeError(str(e))&#10;&#10;    def _validate_product(self, document):&#10;        required_fields = [&quot;title&quot;, &quot;price&quot;, &quot;description&quot;, &quot;category&quot;, &quot;image&quot;]&#10;        missing = [f for f in required_fields if f not in document]&#10;        if missing:&#10;            raise ValueError(f&quot;Missing required field(s): {', '.join(missing)}&quot;)&#10;        try:&#10;            document[&quot;price&quot;] = float(document[&quot;price&quot;])&#10;        except (ValueError, TypeError):&#10;            raise ValueError(&quot;Price must be a number&quot;)&#10;&#10;    def _validate_user(self, document):&#10;        if &quot;email&quot; not in document:&#10;            raise ValueError(&quot;Email is required&quot;)&#10;        if &quot;username&quot; not in document:&#10;            raise ValueError(&quot;Username is required&quot;)&#10;        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'&#10;        if not re.match(email_pattern, str(document[&quot;email&quot;])):&#10;            raise ValueError(&quot;Invalid email format&quot;)&#10;&#10;    def _validate_category(self, document):&#10;        if &quot;name&quot; not in document:&#10;            raise ValueError(&quot;Category name is required&quot;)&#10;&#10;    def _validate_order(self, document):&#10;        if &quot;userId&quot; not in document:&#10;            raise ValueError(&quot;UserId is required&quot;)&#10;        if &quot;products&quot; not in document:&#10;            raise ValueError(&quot;Products array is required&quot;)&#10;        if not isinstance(document[&quot;products&quot;], list):&#10;            raise ValueError(&quot;Products must be an array&quot;)&#10;&#10;    @keyword('Insert Document')&#10;    def insert_document(self, collection_name, document):&#10;        &quot;&quot;&quot;Insert a document into MongoDB collection.&quot;&quot;&quot;&#10;        if not self._db:&#10;            raise RuntimeError(&quot;Not connected to database&quot;)&#10;&#10;        try:&#10;            # Validate document based on collection type&#10;            if collection_name == &quot;products&quot;:&#10;                self._validate_product(document)&#10;            elif collection_name == &quot;users&quot;:&#10;                self._validate_user(document)&#10;            elif collection_name == &quot;categories&quot;:&#10;                self._validate_category(document)&#10;            elif collection_name == &quot;orders&quot;:&#10;                self._validate_order(document)&#10;&#10;            collection = self._db[collection_name]&#10;&#10;            # Check for duplicates in categories&#10;            if collection_name == &quot;categories&quot; and &quot;name&quot; in document:&#10;                existing = collection.find_one({&quot;name&quot;: document[&quot;name&quot;]})&#10;                if existing:&#10;                    raise ValueError(f&quot;Category with name '{document['name']}' already exists&quot;)&#10;&#10;            result = collection.insert_one(document)&#10;            logger.info(f&quot;Document inserted in {collection_name}&quot;)&#10;            return str(result.inserted_id)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error inserting document: {str(e)}&quot;)&#10;            raise&#10;&#10;    @keyword('Find Document')&#10;    def find_document(self, collection_name, query):&#10;        &quot;&quot;&quot;Find a document in MongoDB collection.&quot;&quot;&quot;&#10;        if not self._db:&#10;            raise RuntimeError(&quot;Not connected to database&quot;)&#10;&#10;        try:&#10;            if not isinstance(query, dict):&#10;                raise ValueError(&quot;Query must be a valid dictionary&quot;)&#10;&#10;            collection = self._db[collection_name]&#10;            result = collection.find_one(query)&#10;            if result:&#10;                result['_id'] = str(result['_id'])&#10;                logger.info(f&quot;Document found in {collection_name}&quot;)&#10;            else:&#10;                logger.info(f&quot;No document found in {collection_name}&quot;)&#10;            return result&#10;        except Exception as e:&#10;            logger.error(f&quot;Error finding document: {str(e)}&quot;)&#10;            raise&#10;&#10;    @keyword('Update Document')&#10;    def update_document(self, collection_name, query, update):&#10;        &quot;&quot;&quot;Update a document in MongoDB collection.&quot;&quot;&quot;&#10;        if not self._db:&#10;            raise RuntimeError(&quot;Not connected to database&quot;)&#10;&#10;        try:&#10;            if not isinstance(query, dict):&#10;                raise ValueError(&quot;Query must be a valid dictionary&quot;)&#10;&#10;            collection = self._db[collection_name]&#10;            if not any(key.startswith('$') for key in update.keys()):&#10;                update = {'$set': update}&#10;&#10;            result = collection.update_one(query, update)&#10;            if result.matched_count == 0:&#10;                raise ValueError(&quot;No document found matching the query&quot;)&#10;&#10;            logger.info(f&quot;Document updated in {collection_name}&quot;)&#10;            return result.modified_count&#10;        except Exception as e:&#10;            logger.error(f&quot;Error updating document: {str(e)}&quot;)&#10;            raise&#10;&#10;    @keyword('Delete Document')&#10;    def delete_document(self, collection_name, query):&#10;        &quot;&quot;&quot;Delete a document from MongoDB collection.&quot;&quot;&quot;&#10;        if not self._db:&#10;            raise RuntimeError(&quot;Not connected to database&quot;)&#10;&#10;        try:&#10;            if not isinstance(query, dict):&#10;                raise ValueError(&quot;Query must be a valid dictionary&quot;)&#10;&#10;            collection = self._db[collection_name]&#10;            result = collection.delete_one(query)&#10;            if result.deleted_count == 0:&#10;                raise ValueError(&quot;No document found matching the query&quot;)&#10;&#10;            logger.info(f&quot;Document deleted from {collection_name}&quot;)&#10;            return result.deleted_count&#10;        except Exception as e:&#10;            logger.error(f&quot;Error deleting document: {str(e)}&quot;)&#10;            raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/categories_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/categories_tests.robot" />
              <option name="updatedContent" value="*** Settings ***&#10;Library    Collections&#10;Resource    ../ressources/common.robot&#10;Variables    ../po/variable.py&#10;&#10;*** Test Cases ***&#10;# Tests CRUD pour les catégories&#10;&#10;# CREATE TESTS&#10;Create Category - Valid&#10;    [Documentation]    Test création valide d'une catégorie&#10;    ...    Ce test DOIT PASSER car tous les champs sont valides&#10;    Connect To DB    ${DB_URI}&#10;    Insert Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot;, &quot;description&quot;: &quot;Test Description&quot; }&#10;    Disconnect From DB&#10;&#10;Create Category - Duplicate Name&#10;    [Documentation]    Test création catégorie avec un nom qui existe déjà&#10;    ...    Ce test DOIT ÉCHOUER car le nom de catégorie doit être unique&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }&#10;    Disconnect From DB&#10;&#10;Create Category - Missing Required Field&#10;    [Documentation]    Test création catégorie sans nom&#10;    ...    Ce test DOIT ÉCHOUER car le nom est obligatoire&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${CATEGORIES_COLLECTION}    { &quot;description&quot;: &quot;No Name&quot; }&#10;    Disconnect From DB&#10;&#10;# READ TESTS&#10;Read Category - Valid&#10;    [Documentation]    Test lecture d'une catégorie existante&#10;    ...    Ce test DOIT PASSER car la catégorie existe&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }&#10;    Should Not Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Read Category - Invalid Query Format&#10;    [Documentation]    Test lecture avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Find Document    ${CATEGORIES_COLLECTION}    { invalid_query }&#10;    Disconnect From DB&#10;&#10;Read Category - Non-Existent Category&#10;    [Documentation]    Test lecture d'une catégorie inexistante&#10;    ...    Ce test DOIT PASSER mais retourner None&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Non-existent Category&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;# UPDATE TESTS&#10;Update Category - Valid&#10;    [Documentation]    Test mise à jour valide d'une catégorie&#10;    ...    Ce test DOIT PASSER et la description doit être mise à jour&#10;    Connect To DB    ${DB_URI}&#10;    Update Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }    { &quot;description&quot;: &quot;Updated Description&quot; }&#10;    ${result}=    Find Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }&#10;    Should Be Equal    ${result}[description]    Updated Description&#10;    Disconnect From DB&#10;&#10;Update Category - Invalid Query Format&#10;    [Documentation]    Test mise à jour avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${CATEGORIES_COLLECTION}    { invalid_query }    { &quot;description&quot;: &quot;test&quot; }&#10;    Disconnect From DB&#10;&#10;Update Category - Invalid Update Format&#10;    [Documentation]    Test mise à jour avec un format invalide&#10;    ...    Ce test DOIT ÉCHOUER car le format de mise à jour n'est pas valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }    { invalid_update }&#10;    Disconnect From DB&#10;&#10;# DELETE TESTS&#10;Delete Category - Valid&#10;    [Documentation]    Test suppression valide d'une catégorie&#10;    ...    Ce test DOIT PASSER et la catégorie ne doit plus exister après&#10;    Connect To DB    ${DB_URI}&#10;    Delete Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }&#10;    ${result}=    Find Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Test Category&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Delete Category - Invalid Query Format&#10;    [Documentation]    Test suppression avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Delete Document    ${CATEGORIES_COLLECTION}    { invalid_query }&#10;    Disconnect From DB&#10;&#10;Delete Category - Non-Existent Category&#10;    [Documentation]    Test suppression d'une catégorie inexistante&#10;    ...    Ce test DOIT PASSER mais avec deleted_count = 0&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Delete Document    ${CATEGORIES_COLLECTION}    { &quot;name&quot;: &quot;Non-existent Category&quot; }&#10;    Should Be Equal    ${result.deleted_count}    ${0}&#10;    Disconnect From DB" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/mongo_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/mongo_tests.robot" />
              <option name="updatedContent" value="*** Settings ***&#10;Documentation     Tests de la base de données MongoDB&#10;Resource          ../ressources/common.robot&#10;Variables         ../po/variable.py&#10;Suite Setup       Connect To DB    ${DB_URI}    ${DB_NAME}&#10;Suite Teardown    Disconnect From DB&#10;&#10;*** Test Cases ***&#10;# Tests CRUD pour les produits&#10;Create Product - Valid&#10;    [Documentation]    Test de création d'un produit valide ✓ DOC&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    Should Not Be Empty    ${id}&#10;    Verify Document Exists    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;&#10;Create Product - Invalid Missing Required Field&#10;    [Documentation]    Test de création avec champ requis manquant ✗ DOC&#10;    &amp;{invalid_product}=    Create Dictionary    title=Test Product&#10;    Run Keyword And Expect Error    *Missing required field*    Insert Document    ${PRODUCTS_COLLECTION}    ${invalid_product}&#10;&#10;Create Product - Invalid Wrong Data Type&#10;    [Documentation]    Test de création avec type de données incorrect ✗ DOC&#10;    ${product}=    Create Test Product    price=not a number&#10;    Run Keyword And Expect Error    *Price must be a number*    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;&#10;Read Product - Valid&#10;    [Documentation]    Test de lecture d'un produit existant ✓ DOC&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    ${result}=    Find Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;    Should Be Equal    ${result}[title]    ${product}[title]&#10;&#10;Read Product - Invalid Query Format&#10;    [Documentation]    Test de lecture avec requête invalide ✗ DOC&#10;    Run Keyword And Expect Error    *Query must be a valid dictionary*    Find Document    ${PRODUCTS_COLLECTION}    invalid_query&#10;&#10;Read Product - Non-Existent Product&#10;    [Documentation]    Test de lecture d'un produit inexistant ✗ DOC&#10;    ${result}=    Find Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;nonexistent&quot;}&#10;    Should Be Equal    ${result}    ${None}&#10;&#10;Update Product - Valid&#10;    [Documentation]    Test de mise à jour valide d'un produit ✓ DOC&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    ${update}=    Create Dictionary    price=25.99&#10;    ${count}=    Update Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}    ${update}&#10;    Should Be Equal As Integers    ${count}    ${1}&#10;&#10;Update Product - Invalid Query&#10;    [Documentation]    Test de mise à jour avec requête invalide ✗ DOC&#10;    ${update}=    Create Dictionary    price=25.99&#10;    Run Keyword And Expect Error    *Query must be a valid dictionary*    Update Document    ${PRODUCTS_COLLECTION}    invalid_query    ${update}&#10;&#10;Delete Product - Valid&#10;    [Documentation]    Test de suppression valide d'un produit ✓ DOC&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    ${count}=    Delete Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;    Should Be Equal As Integers    ${count}    ${1}&#10;&#10;Delete Product - Non-Existent Product&#10;    [Documentation]    Test de suppression d'un produit inexistant ✗ DOC&#10;    Run Keyword And Expect Error    *No document found*    Delete Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;nonexistent&quot;}&#10;&#10;# Tests CRUD pour les utilisateurs&#10;Create User - Valid&#10;    [Documentation]    Test de création d'un utilisateur valide ✓ DOC&#10;    ${user}=    Create Test User&#10;    ${id}=    Insert Document    ${USERS_COLLECTION}    ${user}&#10;    Should Not Be Empty    ${id}&#10;    Verify Document Exists    ${USERS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;&#10;Create User - Invalid Email Format&#10;    [Documentation]    Test de création avec email invalide ✗ DOC&#10;    ${user}=    Create Test User    email=invalid_email&#10;    Run Keyword And Expect Error    *Invalid email format*    Insert Document    ${USERS_COLLECTION}    ${user}&#10;&#10;# Tests CRUD pour les catégories&#10;Create Category - Valid&#10;    [Documentation]    Test de création d'une catégorie valide ✓ DOC&#10;    ${category}=    Create Test Category&#10;    ${id}=    Insert Document    ${CATEGORIES_COLLECTION}    ${category}&#10;    Should Not Be Empty    ${id}&#10;    Verify Document Exists    ${CATEGORIES_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;&#10;Create Category - Duplicate Name&#10;    [Documentation]    Test de création avec nom dupliqué ✗ DOC&#10;    ${category}=    Create Test Category    name=Unique Category&#10;    Insert Document    ${CATEGORIES_COLLECTION}    ${category}&#10;    Run Keyword And Expect Error    *already exists*    Insert Document    ${CATEGORIES_COLLECTION}    ${category}&#10;&#10;# Tests CRUD pour les commandes&#10;Create Order - Valid&#10;    [Documentation]    Test de création d'une commande valide ✓ DOC&#10;    ${order}=    Create Test Order&#10;    ${id}=    Insert Document    ${ORDERS_COLLECTION}    ${order}&#10;    Should Not Be Empty    ${id}&#10;    Verify Document Exists    ${ORDERS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;&#10;Create Order - Invalid Products Format&#10;    [Documentation]    Test de création avec format de produits invalide ✗ DOC&#10;    &amp;{invalid_order}=    Create Dictionary    userId=testuser    products=not_an_array&#10;    Run Keyword And Expect Error    *Products must be an array*    Insert Document    ${ORDERS_COLLECTION}    ${invalid_order}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/mongodb_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/mongodb_tests.robot" />
              <option name="updatedContent" value="*** Settings ***&#10;Documentation     Tests de la base de données MongoDB - Tests CRUD&#10;Library          Collections&#10;Library          String&#10;Variables        ../po/variable.py&#10;&#10;*** Variables ***&#10;${DECIMAL_SEPARATOR}    .&#10;&#10;*** Keywords ***&#10;Connect To Database&#10;    [Arguments]    ${uri}    ${db_name}=fakestore&#10;    Import Library    pymongo.MongoClient    ${uri}&#10;    ${client}=    Evaluate    pymongo.MongoClient(&quot;${uri}&quot;)&#10;    ${db}=    Set Variable    ${client}[${db_name}]&#10;    Set Suite Variable    ${MONGODB_CLIENT}    ${client}&#10;    Set Suite Variable    ${MONGODB_DB}    ${db}&#10;    ${result}=    Evaluate    ${MONGODB_CLIENT}.admin.command('ping')&#10;    Should Not Be Empty    ${result}&#10;&#10;Disconnect From Database&#10;    Evaluate    ${MONGODB_CLIENT}.close()&#10;    Set Suite Variable    ${MONGODB_CLIENT}    ${None}&#10;    Set Suite Variable    ${MONGODB_DB}    ${None}&#10;&#10;Insert Document&#10;    [Arguments]    ${collection}    ${document}&#10;    ${coll}=    Set Variable    ${MONGODB_DB}[${collection}]&#10;    ${result}=    Evaluate    ${coll}.insert_one(${document})&#10;    [Return]    ${result.inserted_id}&#10;&#10;Find Document&#10;    [Arguments]    ${collection}    ${query}&#10;    ${coll}=    Set Variable    ${MONGODB_DB}[${collection}]&#10;    ${result}=    Evaluate    ${coll}.find_one(${query})&#10;    [Return]    ${result}&#10;&#10;Update Document&#10;    [Arguments]    ${collection}    ${query}    ${update}&#10;    ${coll}=    Set Variable    ${MONGODB_DB}[${collection}]&#10;    ${update_dict}=    Create Dictionary    $set=${update}&#10;    ${result}=    Evaluate    ${coll}.update_one(${query}, ${update_dict})&#10;    [Return]    ${result.modified_count}&#10;&#10;Delete Document&#10;    [Arguments]    ${collection}    ${query}&#10;    ${coll}=    Set Variable    ${MONGODB_DB}[${collection}]&#10;    ${result}=    Evaluate    ${coll}.delete_one(${query})&#10;    [Return]    ${result.deleted_count}&#10;&#10;Create Test Product&#10;    [Arguments]    ${title}=Test Product    ${price}=10.99&#10;    &amp;{product}=    Create Dictionary&#10;    ...    title=${title}&#10;    ...    price=${price}&#10;    ...    description=A test product&#10;    ...    category=test&#10;    ...    image=http://test.com/image.jpg&#10;    [Return]    ${product}&#10;&#10;Create Test User&#10;    [Arguments]    ${email}=test@test.com    ${username}=testuser&#10;    &amp;{user}=    Create Dictionary&#10;    ...    email=${email}&#10;    ...    username=${username}&#10;    ...    password=test123&#10;    [Return]    ${user}&#10;&#10;Create Test Category&#10;    [Arguments]    ${name}=Test Category&#10;    &amp;{category}=    Create Dictionary&#10;    ...    name=${name}&#10;    ...    description=Test Description&#10;    [Return]    ${category}&#10;&#10;Create Test Order&#10;    [Arguments]    ${user_id}=testuser&#10;    &amp;{product}=    Create Dictionary&#10;    ...    productId=testproduct&#10;    ...    quantity=${1}&#10;    @{products}=    Create List    ${product}&#10;    &amp;{order}=    Create Dictionary&#10;    ...    userId=${user_id}&#10;    ...    products=${products}&#10;    [Return]    ${order}&#10;&#10;*** Test Cases ***&#10;Create Product Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    Should Not Be Empty    ${id}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Create User Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${user}=    Create Test User&#10;    ${id}=    Insert Document    ${USERS_COLLECTION}    ${user}&#10;    Should Not Be Empty    ${id}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Read Product Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    ${result}=    Find Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;    Should Not Be Empty    ${result}&#10;    Should Be Equal    ${result}[title]    ${product}[title]&#10;    [Teardown]    Disconnect From Database&#10;&#10;Update Product Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    &amp;{update}=    Create Dictionary    price=25.99&#10;    ${count}=    Update Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}    ${update}&#10;    Should Be Equal As Integers    ${count}    ${1}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Delete Product Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${product}=    Create Test Product&#10;    ${id}=    Insert Document    ${PRODUCTS_COLLECTION}    ${product}&#10;    ${count}=    Delete Document    ${PRODUCTS_COLLECTION}    {&quot;_id&quot;: &quot;${id}&quot;}&#10;    Should Be Equal As Integers    ${count}    ${1}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Invalid Product Creation Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${invalid_product}=    Create Dictionary    title=Test Product    price=invalid&#10;    Run Keyword And Expect Error    *    Insert Document    ${PRODUCTS_COLLECTION}    ${invalid_product}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Invalid User Email Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${invalid_user}=    Create Test User    email=invalid-email&#10;    Run Keyword And Expect Error    *    Insert Document    ${USERS_COLLECTION}    ${invalid_user}&#10;    [Teardown]    Disconnect From Database&#10;&#10;Duplicate Category Test&#10;    [Setup]    Connect To Database    ${DB_URI}&#10;    ${category}=    Create Test Category    name=Unique Category&#10;    Insert Document    ${CATEGORIES_COLLECTION}    ${category}&#10;    Run Keyword And Expect Error    *    Insert Document    ${CATEGORIES_COLLECTION}    ${category}&#10;    [Teardown]    Disconnect From Database" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/orders_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/orders_tests.robot" />
              <option name="updatedContent" value="*** Settings ***&#10;Library    Collections&#10;Resource    ../ressources/common.robot&#10;Variables    ../po/variable.py&#10;&#10;*** Test Cases ***&#10;# Tests CRUD pour les commandes&#10;&#10;# CREATE TESTS&#10;Create Order - Valid&#10;    [Documentation]    Test création valide d'une commande&#10;    ...    Ce test DOIT PASSER car tous les champs sont valides&#10;    Connect To DB    ${DB_URI}&#10;    Insert Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot;, &quot;products&quot;: [{ &quot;productId&quot;: &quot;testproduct&quot;, &quot;quantity&quot;: 1 }], &quot;date&quot;: &quot;2025-07-31T00:00:00.000Z&quot; }&#10;    Disconnect From DB&#10;&#10;Create Order - Invalid Products Format&#10;    [Documentation]    Test création commande avec format de produits invalide&#10;    ...    Ce test DOIT ÉCHOUER car products doit être un tableau&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot;, &quot;products&quot;: &quot;invalid&quot; }&#10;    Disconnect From DB&#10;&#10;Create Order - Missing Required Fields&#10;    [Documentation]    Test création commande sans produits&#10;    ...    Ce test DOIT ÉCHOUER car products est obligatoire&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }&#10;    Disconnect From DB&#10;&#10;# READ TESTS&#10;Read Order - Valid&#10;    [Documentation]    Test lecture d'une commande existante&#10;    ...    Ce test DOIT PASSER car la commande existe&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }&#10;    Should Not Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Read Order - Invalid Query Format&#10;    [Documentation]    Test lecture avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Find Document    ${ORDERS_COLLECTION}    { invalid_query }&#10;    Disconnect From DB&#10;&#10;Read Order - Non-Existent Order&#10;    [Documentation]    Test lecture d'une commande inexistante&#10;    ...    Ce test DOIT PASSER mais retourner None&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;nonexistent&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;# UPDATE TESTS&#10;Update Order - Valid&#10;    [Documentation]    Test mise à jour valide de la quantité d'un produit&#10;    ...    Ce test DOIT PASSER et la quantité doit être mise à jour&#10;    Connect To DB    ${DB_URI}&#10;    Update Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }    { &quot;products&quot;: [{ &quot;productId&quot;: &quot;testproduct&quot;, &quot;quantity&quot;: 2 }] }&#10;    ${result}=    Find Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }&#10;    Should Be Equal    ${result}[products][0][quantity]    ${2}&#10;    Disconnect From DB&#10;&#10;Update Order - Invalid Query Format&#10;    [Documentation]    Test mise à jour avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${ORDERS_COLLECTION}    { invalid_query }    { &quot;products&quot;: [] }&#10;    Disconnect From DB&#10;&#10;Update Order - Invalid Update Format&#10;    [Documentation]    Test mise à jour avec un format invalide&#10;    ...    Ce test DOIT ÉCHOUER car le format de mise à jour n'est pas valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }    { invalid_update }&#10;    Disconnect From DB&#10;&#10;# DELETE TESTS&#10;Delete Order - Valid&#10;    [Documentation]    Test suppression valide d'une commande&#10;    ...    Ce test DOIT PASSER et la commande ne doit plus exister après&#10;    Connect To DB    ${DB_URI}&#10;    Delete Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }&#10;    ${result}=    Find Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;testuser&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Delete Order - Invalid Query Format&#10;    [Documentation]    Test suppression avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Delete Document    ${ORDERS_COLLECTION}    { invalid_query }&#10;    Disconnect From DB&#10;&#10;Delete Order - Non-Existent Order&#10;    [Documentation]    Test suppression d'une commande inexistante&#10;    ...    Ce test DOIT PASSER mais avec deleted_count = 0&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Delete Document    ${ORDERS_COLLECTION}    { &quot;userId&quot;: &quot;nonexistent&quot; }&#10;    Should Be Equal    ${result.deleted_count}    ${0}&#10;    Disconnect From DB" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/products_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/products_tests.robot" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lab1/testcases/users_tests.robot">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lab1/testcases/users_tests.robot" />
              <option name="updatedContent" value="*** Settings ***&#10;Library    Collections&#10;Resource    ../ressources/common.robot&#10;Variables    ../po/variable.py&#10;&#10;*** Test Cases ***&#10;# Tests CRUD pour les utilisateurs&#10;&#10;# CREATE TESTS&#10;Create User - Valid&#10;    [Documentation]    Test création valide d'un utilisateur avec tous les champs requis&#10;    ...    Ce test DOIT PASSER car l'email et le username sont valides&#10;    Connect To DB    ${DB_URI}&#10;    Insert Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot;, &quot;username&quot;: &quot;testuser&quot;, &quot;password&quot;: &quot;pass123&quot;, &quot;name&quot;: { &quot;firstname&quot;: &quot;Test&quot;, &quot;lastname&quot;: &quot;User&quot; } }&#10;    Disconnect From DB&#10;&#10;Create User - Invalid Email Format&#10;    [Documentation]    Test création utilisateur avec email invalide&#10;    ...    Ce test DOIT ÉCHOUER car le format de l'email n'est pas valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;invalid-email&quot;, &quot;username&quot;: &quot;testuser&quot; }&#10;    Disconnect From DB&#10;&#10;Create User - Missing Required Fields&#10;    [Documentation]    Test création utilisateur sans email&#10;    ...    Ce test DOIT ÉCHOUER car l'email est obligatoire&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Insert Document    ${USERS_COLLECTION}    { &quot;username&quot;: &quot;incomplete&quot; }&#10;    Disconnect From DB&#10;&#10;# READ TESTS&#10;Read User - Valid&#10;    [Documentation]    Test lecture d'un utilisateur existant&#10;    ...    Ce test DOIT PASSER car l'utilisateur existe&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }&#10;    Should Not Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Read User - Invalid Query Format&#10;    [Documentation]    Test lecture avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Find Document    ${USERS_COLLECTION}    { invalid_query }&#10;    Disconnect From DB&#10;&#10;Read User - Non-Existent User&#10;    [Documentation]    Test lecture d'un utilisateur inexistant&#10;    ...    Ce test DOIT PASSER mais retourner None&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Find Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;nonexistent@test.com&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;# UPDATE TESTS&#10;Update User - Valid&#10;    [Documentation]    Test mise à jour valide du mot de passe&#10;    ...    Ce test DOIT PASSER et le mot de passe doit être mis à jour&#10;    Connect To DB    ${DB_URI}&#10;    Update Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }    { &quot;password&quot;: &quot;newpass123&quot; }&#10;    ${result}=    Find Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }&#10;    Should Be Equal    ${result}[password]    newpass123&#10;    Disconnect From DB&#10;&#10;Update User - Invalid Query Format&#10;    [Documentation]    Test mise à jour avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${USERS_COLLECTION}    { invalid_query }    { &quot;password&quot;: &quot;test&quot; }&#10;    Disconnect From DB&#10;&#10;Update User - Invalid Update Format&#10;    [Documentation]    Test mise à jour avec un format invalide&#10;    ...    Ce test DOIT ÉCHOUER car le format de mise à jour n'est pas valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Update Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }    { invalid_update }&#10;    Disconnect From DB&#10;&#10;# DELETE TESTS&#10;Delete User - Valid&#10;    [Documentation]    Test suppression valide d'un utilisateur&#10;    ...    Ce test DOIT PASSER et l'utilisateur ne doit plus exister après&#10;    Connect To DB    ${DB_URI}&#10;    Delete Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }&#10;    ${result}=    Find Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;test@test.com&quot; }&#10;    Should Be Equal    ${result}    ${None}&#10;    Disconnect From DB&#10;&#10;Delete User - Invalid Query Format&#10;    [Documentation]    Test suppression avec une requête invalide&#10;    ...    Ce test DOIT ÉCHOUER car la requête n'est pas un JSON valide&#10;    Connect To DB    ${DB_URI}&#10;    Run Keyword And Expect Error    *    Delete Document    ${USERS_COLLECTION}    { invalid_query }&#10;    Disconnect From Database&#10;&#10;Delete User - Non-Existent User&#10;    [Documentation]    Test suppression d'un utilisateur inexistant&#10;    ...    Ce test DOIT PASSER mais avec deleted_count = 0&#10;    Connect To DB    ${DB_URI}&#10;    ${result}=    Delete Document    ${USERS_COLLECTION}    { &quot;email&quot;: &quot;nonexistent@test.com&quot; }&#10;    Should Be Equal    ${result.deleted_count}    ${0}&#10;    Disconnect From Database" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>